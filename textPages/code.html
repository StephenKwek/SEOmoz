<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.5  (Linux)">
	<META NAME="AUTHOR" CONTENT="Stephen Kwek">
	<META NAME="CREATED" CONTENT="20121222;16173200">
	<META NAME="CHANGEDBY" CONTENT="Stephen Kwek">
	<META NAME="CHANGED" CONTENT="20121223;21540500">
	<META NAME="CHANGEDBY" CONTENT="Stephen Kwek">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P ALIGN=CENTER STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Code
Samples</FONT></FONT></P>
<P>The types of typical software developer interview coding questions
(as can be found in glassdoor.com) can be categorized into the
following topics. I have identified one or two problems that are
either more challenging or most representative of each topic and have
written some code for it. The code are written in C. Topics 10 has no
code but has an interesting discussion on a problem involving
optimizating the worst case to get good lower-bound. 
</P>
<OL>
	<LI><P><B>Binary Search</B>: Binary search is a common question, be
	it standard binary search, (STL) lowerbound, upperbound and range
	algorithms, binary search on two or more sorted arrays, etc. A more
	challenging question in this topic is the following, which I would
	encourage you to take sometime to think about it before looking at
	the comment or code. 
	</P>
	<P>Problem: Implement log_2 using square root only. In other words,
	given a constant c, we want to find y s.t. 2^y – c = 0. 
	</P>
	<P>Comment: Without the restriction, one could simply use
	Newton-Raphspn method or binary search on the line 2^y by searching
	for 2^y ~ c. With this restriction, instead of performing binary
	search on the line 2^y, we perform search on y = log(2^y) by making
	use of the fact that on the line y, the mid-point of y_1 and y_2
	corresponds to (log(2^y_1) + log(2^y_2))/2 = log(2^y_1 * 2^y_2)/2 =
	sqrt(y_1*y_2). Effectively, instead of doing an 'even-split search
	with mid-point (y_1 + y_2)/2, we have the mid-point being sqrt(y_1 *
	y_2). 
	</P>
	<P>Code: <A HREF="log2">available here</A>. 
	</P>
	<LI><P><B>Linear Sweep</B> (including Greedy algorithms): Here, we
	are usually given an array of numbers and asked to produce an
	optimal solution that consists of either a single (or a pair of )
	instance of the array, or a subarray that produces some optimum
	measure. The typical approach is to initialize the current best
	solution as you scan from 'left to right', and when a better
	solution is found, update the best solution. 
	</P>
	<OL>
		<P>Problem: Given the price of a given stock at da<SPAN STYLE="font-weight: normal">y
		i,</SPAN> find the best time to sell and buy stock. You are only
		permitted to complete at most one transaction (buy the stock and
		then sell it later, no shorting). 
		</P>
		<P>Comment: 
		</P>
		<P>Code: <A HREF="stock">available here</A>.</P>
	</OL>
	<LI><P><B>Dynamic Programming</B>: In a nutshell, dynamic
	programming starts with solutions for the trivial cases (i,e
	boundary condition) and subsequently, extend the partial solution to
	even larger partial solution (using a recurrence relation) until we
	solved the entire problem. It involves maintaining a data structure,
	typically in the form of an array (could be 1D, 2D, 3D, etc).
	Sometime the data structure could be a tree, a triangular matrix, or
	a graph with partial (linear) order. 
	</P>
	<OL>
		<P>Problem: Given a NxM rectangular grid, a robot can travel from a
		cell to a neighboring cells. However, a small number of edges in
		these grids are missing. Compute how many possible (shortest) paths
		are there from the top-left corner to the bottom-right corner. 
		</P>
		<P>Comment: Assuming that N and M can be quite large, the
		straightforward approach of maintaining a 2D table may not be
		feasible and it is not memory efficient to store the missing edges
		in a sparse adjacency matrix. 
		</P>
		<P>Code: There are three versions of the code, the first uses a 2D
		O(MN) table, the second maintain the current two O(M) rows that we
		are processing. The last maintain only 1 row. 
		</P>
	</OL>
	<LI><P><B>Recursion, Depth(or Breath)-first-search</B>: 
	</P>
	<OL>
		<P>Problem: Given an NxN 'chessboard', find a placement of N queen
		so that none of them can hit each other. You function should takes
		in N and printout the queen placement if it is possible.</P>
		<P>Comment: A queen can dominate a row, a column, a diagonal from
		top-left to bottom right (denote it as tl_br) or top-right to
		bottom-left (denote it as tr-bl). For a queen at position (i, j),
		we say it dominates the (i+j) tl_br diagonal and (N-1-i+j) tr_bl
		diagonal. Further, for efficiency, we do not need to create the
		entire NxN board as we are processing the rows from top to bottom.
		We 'just need' to keep track of which column we placed the queen.</P>
		<P>Code: available here. 
		</P>
	</OL>
	<LI><P><B>Binary-tree Manipulation: </B><SPAN STYLE="font-weight: normal">Examples
	are tree-traveral, transforming tree from one type to another,
	serialization and deserialization, finding the shortest height of
	the tree, etc. Most of the solutions to these problems involved
	recursion. I pick the following problem as it is a good
	representation of this type of problems. </SPAN>
	</P>
	<OL>
		<P STYLE="font-weight: normal">Problem: Given a binary-tree,
		determine if it is a valid binary search tree. A bonus point is to
		check that it is indeed a tree (a tree is a graph with all nodes
		connected but without cycle). 
		</P>
		<P STYLE="font-weight: normal">Comment: There are a number of ways
		to solve this. My favorite is to use the fact that if the
		binary-tree is indeed a binary search tree than the values of the
		nodes visited in an in-order traversal are in monotonically
		increasing order. 
		</P>
		<P STYLE="font-weight: normal">Code: <A HREF="checkBST">available
		here</A>.</P>
	</OL>
	<LI><P><B>String Parsing</B>: write a simple regular expression
	matcher, evaluation of arithmetic expression, palindrome-related
	questions. 
	</P>
	<OL>
		<P>Problem: Write a simple pattern matching function that match '.'
		to any single character and '*' to any normal of the preceding
		characters. Example match(“aa”, “a”), match(“aaa”,”aa”)
		return false, while match (“aaab”, “a*a*b”) and
		match(“aaaba”, “a*.a”) return true.</P>
		<P>Code: <A HREF="matchPattern">available here</A>.</P>
		<P>Another interesting problem that written in C/C++ will take a
		few lines but in python is a one liner. 
		</P>
		<P>Code: ' '.join([w[::-1] for w in line.split(' ')])</P>
	</OL>
	<LI><P><B>Combinatorial Enumeration</B>: powerset, permutation and
	combinatrion with/with item duplications. My favorite is 
	</P>
	<OL>
		<P>Problem (Gray Code): Enumerate all length N {0,1}-string such
		that consecutive strings differ by only 1-bit. 
		</P>
		<P>Comment: For a given N, gray code is uniquely defined (subject
		to rotation). 
		</P>
		<P>Code: available here. 
		</P>
	</OL>
	<LI><P><B>Bit Manipulation</B>: Normally, involve writing a 1 liner
	code (or few lines), say to determine if a binary string represents
	an integer of power of 2. A problem slightly related to bit
	manipulation is 
	</P>
	<OL>
		<P>Problem: perform division without multiplication.</P>
		<P>Code: available here.</P>
	</OL>
	<LI><P><B>List (pointer) Manipulation</B>: basic linked list, double
	linked list problems. The classic (attributed to MS I believe)
	being:</P>
	<OL>
		<P>Problem: Given a linked list, determine if there is a loop.</P>
		<P>Comment: The solution is to have a fast pointer traveling two
		nodes in one iteration and one slow pointer traveling one node at a
		time. If there is no loop, the fast pointer will fall off the list
		whereas the 
		</P>
	</OL>
	<LI><P><B>Sorting, (linear) Search and Merging</B>: Most of the
	questions in this category seem to be straight from the textbook,
	some with slight variation. A cute problem with short simple
	solution is the following. 
	</P>
	<OL>
		<P>Problem: A vector with a specific number occuring more than half
		of the time.</P>
	</OL>
</OL>
</BODY>
</HTML>